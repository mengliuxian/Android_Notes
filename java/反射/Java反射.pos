{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","structure":"mind_free","leftChildren":[],"title":"Java反射","root":true,"theme":"default","children":[{"id":"f866bc9f1d12","title":"概念","parent":"root","children":[{"id":"1c91165544dd","title":"1.反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。","parent":"f866bc9f1d12","children":[]},{"id":"f30f7bde306e","title":"2.反射可以在一个类运行的时候获取类的信息的机制，可以获取在编译期不可能获得的类的信息。","parent":"f866bc9f1d12","children":[]},{"id":"c7cd87b7b0e0","title":"3.对于任意一个对象，都能调用它的任意一个方法和属性。","parent":"f866bc9f1d12","children":[]},{"id":"8ff45107ebea","title":"4.因为类的信息是保存在Class对象中的，而这个Class对象是在程序运行时被类加载器（ClassLoader）动态加载的。","parent":"f866bc9f1d12","children":[]},{"id":"6478cf98a3fd","title":"5.当类加载器装载运行了类后，动态获取Class对象的信息以及动态操作Class对象的属性和方法的功能称为Java语音的反射机制。","parent":"f866bc9f1d12","children":[]}]},{"id":"9cfe305bc980","title":"作用","parent":"root","children":[{"id":"6e27307231be","title":"1.反编译：.class —&gt; .java。","parent":"9cfe305bc980","children":[]},{"id":"9bd91b279ad4","title":"2.通过反射机制访问Java对象中的属性、方法、构造方法等。","parent":"9cfe305bc980","children":[]}]},{"id":"9df04fe3d94d","title":"涉及到的类","parent":"root","children":[{"id":"ce41740f2fd8","title":"1.Class —— 类的创建；","parent":"9df04fe3d94d","children":[{"id":"78c707f341b4","title":"1.获取Class对象的方法","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border":"0px none rgb(255, 255, 255)"},"parent":"ce41740f2fd8","children":[{"tags":[{"text":"会让ClassLoader装载类，并进行","color":"#276F86","background":"#d6f0f8"}],"id":"64a0c6ebb928","title":"1.Class c1 = Class.forName(\"com.mxm.Reflect\");","parent":"78c707f341b4","children":[],"note":""},{"id":"1135c72adeaa","tags":[{"text":"返回类对象运行时真正所指的对象、所属类型","color":"#276F86","background":"#d6f0f8"}],"title":"2.Class c2 = Reflect.class;","parent":"78c707f341b4","children":[]},{"tags":[{"text":"ClassLoader装载入内存，不对类","color":"#276F86","background":"#d6f0f8"}],"id":"54c7979a2d53","title":"3.Class c3 = new Reflect().getClass();","parent":"78c707f341b4","children":[]}]},{"id":"7c0dbf511cee","title":"2.无参数创建对象","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border":"0px none rgb(255, 255, 255)"},"children":[{"tags":[{"text":"newInstance式使用类的加载机制","color":"rgb(39, 111, 134)","background":"rgb(214, 240, 248)"}],"id":"5086fbb366e6","title":"Class c4 = Class。forName(\"com.mxm.Reflect\");<br>Object o = c4.newInstance();","parent":"7c0dbf511cee","children":[]}],"parent":"ce41740f2fd8"},{"id":"1b5a962ac283","title":"3.有参数创建对象","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border":"0px none rgb(255, 255, 255)"},"parent":"ce41740f2fd8","children":[{"id":"deab82736fde","tags":[{"text":"getConstructor方法返回了一","color":"#276F86","background":"#d6f0f8"},{"text":"个Constructor对象，它反映了此","color":"#276F86","background":"#d6f0f8"},{"text":"Class对象所表示的类的指定的公共构造","color":"#276F86","background":"#d6f0f8"}],"title":"Constructor&lt;?&gt; csr = c4.getConstructor(String.class,,int.class);<br>Object o = csr.newInstance(\"王\",28);","children":[],"parent":"1b5a962ac283"}]}]},{"id":"b8c7adbc863b","title":"2.Constructor —— 反射类中构造方法；","parent":"9df04fe3d94d","children":[]},{"id":"46661ffe14df","title":"3.Field —— 反射方法；","parent":"9df04fe3d94d","children":[{"id":"9d526e9fdf6a","title":"1.获取属性","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border":"0px none rgb(255, 255, 255)"},"children":[{"id":"7f9c23c3631e","title":"Field field = class.getDeclaredField(\"name\");<br>使用setAccseeible取消封装，特别是可以取消私有字段的访问权限。<br>field.setAccessible(true);<br>field.set(object,\"老王\");","parent":"9d526e9fdf6a","children":[]}],"parent":"46661ffe14df"},{"id":"65641d603562","title":"2.Field类描述","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border":"0px none rgb(255, 255, 255)"},"parent":"46661ffe14df","children":[{"id":"4a10ac59c931","title":"1.Field类描述的是属性对象，其中可以获取到很多属性信息，包括名字、属性类型、属性的注解。","parent":"65641d603562","children":[]}]},{"id":"c206c77ead43","title":"3.安全管理","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border":"0px none rgb(255, 255, 255)"},"parent":"46661ffe14df","children":[{"id":"691d2ea35f3a","title":"1.在安全管理器中会使用checkPermission方法来检查权限 ，而setAccessible(true)并不是将方法的权限改为public，而是取消Java的权限控制检查，所以即使是public方法，其accessible属性默认也是false。","children":[],"parent":"c206c77ead43"}]},{"id":"9ac9126604b3","title":"4.修改属性中的修饰符","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border":"0px none rgb(255, 255, 255)"},"children":[{"id":"02c4c25eb929","tags":[{"text":"getModofoers()返回的是一个","color":"#276F86","background":"#d6f0f8"},{"text":"代表类、成员变量、方法的修饰符","color":"#276F86","background":"#d6f0f8"}],"title":"Field field = class.getDeclaredField(\"name\");<br>String prive = Modeifier.toString(field.getModofoers());","parent":"9ac9126604b3","children":[]}],"parent":"46661ffe14df"}]},{"id":"7295971bbf25","title":"4.Method —— 反射方法；","parent":"9df04fe3d94d","children":[{"id":"82cc39ce2557","title":"Method m = class.getDeclaredMethod(\"setName\",String.class);<br>m.setAccessible(true); //同样需要忽略访问权限的限制<br>m.invoke(class,\"老王\");<br>","parent":"7295971bbf25","children":[]}]},{"id":"6a174301a1b4","title":"5.Modifier —— 访问修饰符的信息。","parent":"9df04fe3d94d","children":[]}]},{"id":"1fcbaceb53de","title":"反射进阶","parent":"root","children":[{"id":"77ca5ee718ad","title":"1.获取不到Class","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border":"0px none rgb(255, 255, 255)"},"parent":"1fcbaceb53de","children":[{"id":"b71940d15d42","title":"当Class.foeName()中路径获取不到对应的Class时，会抛出异常。","children":[],"parent":"77ca5ee718ad"}]},{"id":"b2b3c762fac2","title":"2.获取不到Field","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border":"0px none rgb(255, 255, 255)"},"children":[{"id":"bfee42c8abd3","title":"1.确实不存在这个Field，抛出异常。","parent":"b2b3c762fac2","children":[]},{"id":"88c913f03b88","title":"2.修饰符导致的权限问题，抛出相同异常。","parent":"b2b3c762fac2","children":[]}],"parent":"1fcbaceb53de"},{"id":"70d5513ad9d9","title":"3.获取父类修饰符","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border":"0px none rgb(255, 255, 255)"},"parent":"1fcbaceb53de","children":[{"id":"22ada7883e1e","title":"1.getField只能获取对象和父类的public修饰的属性。","children":[],"parent":"70d5513ad9d9"},{"id":"1a5d4bd799be","title":"2.getDeclaredField获取对象中的各种修饰符属性，但是不能获取父类的任何属性。","children":[],"parent":"70d5513ad9d9"},{"id":"1b0b6077d205","title":"3.先使用getSupperclass方法可以获取父类的suppereClass对象，再使用getDeclaredField方法获取父类的全部属性","children":[],"parent":"70d5513ad9d9"}]},{"id":"a162898cb521","title":"4.获取不到父类的非public的方法","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border":"0px none rgb(255, 255, 255)"},"children":[],"parent":"1fcbaceb53de"},{"id":"595c35203ffe","title":"5.获取不到父类的构造方法","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border":"0px none rgb(255, 255, 255)"},"parent":"1fcbaceb53de","children":[]},{"id":"727acb06a236","title":"6.newInstance方法创建类对象的两种方法","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border":"0px none rgb(255, 255, 255)"},"children":[{"id":"84d37fdcb23b","title":"1.Class.newInstance()","children":[{"id":"d73f9e9fd6c7","title":"使用受到限制，对应的Class中必须存在一个无参数的构造方法，并且必须要有访问权限。","children":[],"parent":"84d37fdcb23b"}],"parent":"727acb06a236"},{"id":"2658d572474b","title":"2.Contructor.newInstance()","children":[{"id":"4255f5fd1900","title":"适应任何类型的构造方法，无论是否有参数都可以调用，只需要setAccessible()方法控制访问权限。","children":[],"parent":"2658d572474b"}],"parent":"727acb06a236"}],"parent":"1fcbaceb53de"},{"id":"8f946ace394d","title":"7.反射静态方法","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border":"0px none rgb(255, 255, 255)"},"parent":"1fcbaceb53de","children":[{"tags":[{"text":"关键是Method.invoke的第一个","color":"#276F86","background":"#d6f0f8"},{"text":"static方法因为属于类本身","color":"#276F86","background":"#d6f0f8"},{"text":"所以不需要填写对象，填写null就可以","color":"#276F86","background":"#d6f0f8"}],"id":"bfede4f23afd","title":"public class TestMethod{<br>&nbsp; &nbsp; &nbsp; &nbsp;static void test（）{}<br>}<br>Class cla = Class.foeName(\"TestMethod\");<br>Method m = cla.getDeclaredMethod(\"test\");<br>m.invoke(null);","parent":"8f946ace394d","children":[]}]},{"id":"69cac96548a0","title":"8.反射泛型参数方法","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border":"0px none rgb(255, 255, 255)"},"children":[{"id":"8d00b3e6973b","title":"1.Java的泛型擦除概念，泛型T在编译时会自动向上转型为Object","parent":"69cac96548a0","children":[]},{"id":"9cf7a157da9b","title":"public class Test&lt;T&gt;{<br>&nbsp; &nbsp; &nbsp; public void test(T t){}<br>}&nbsp;&nbsp;<br>Class cla = Test.class;<br>Method m = cla.getDeclaredMethod(\"test\",Object.class);<br>m.invoke(new Test&lt;Integer&gt;(),1);<br>","children":[],"parent":"69cac96548a0"}],"parent":"1fcbaceb53de"},{"id":"02ca625b3aa0","title":"9.反射框架：jOOR","style":{"border-radius":"6px","color":"rgb(255, 255, 255)","background-color":"rgb(255, 83, 92)","border":"0px none rgb(255, 255, 255)"},"parent":"1fcbaceb53de","children":[]}]}]}},"meta":{"id":"5cbd77d2e4b01941c8b69f61","member":"5cbd0f71e4b09eb4ac215052","exportTime":"2019-04-24 16:21:18","diagramInfo":{"category":"mind_free","title":"Java反射","created":"2019-04-22 16:14:10","creator":"5cbd0f71e4b09eb4ac215052","modified":"2019-04-24 16:20:11"},"type":"ProcessOn Schema File","version":"1.0"}}